# 队列-事件循环

::: tip

JavaScript 事件循环是一种机制，用于处理异步事件和回调函数。它是 JavaScript 运行时环境的一部分，负责管理事件队列和调用栈。

:::

## javascript 是一个单线程语言

javascript 中的所有任务都只有一条线程在处理。

为了避免一个任务卡死了。那么后面所有的任务都无法被执行。或者有某个任务耗时很长，那么就会导致后面所有的任务都被延迟执行。在这样的环境下，javascript 诞生了两个任务种类：<mark>同步任务</mark>和<mark>异步任务</mark>

## 事件循环的基本原理

事件循环的核心是一个事件队列，所有的事件都被放入这个队列中，然后按照顺序依次执行。如果队列为空，JavaScript 会等待新的任务加入队列。当 JavaScript 代码执行时，<mark>所有同步任务都会被立即执行</mark>，而异步任务则会被放入事件队列中。

当所有同步任务执行完毕后，事件循环会从事件队列中取出一个任务，并将其放入调用栈中执行。当该任务执行完毕后，事件循环会再次从事件队列中取出下一个任务，并重复这个过程。

## 事件循环的执行过程

1. 执行同步代码，直到遇到第一个异步事件（如 setTimeout、setInterval、Promise 等）。

2. 将异步事件放入事件队列中，并继续执行同步代码。

3. 当所有同步代码执行完毕后，JavaScript 引擎会检查事件队列中是否有事件需要执行。

4. 如果事件队列中有事件需要执行，JavaScript 引擎会将第一个事件取出来，并执行对应的回调函数。

5. 执行完回调函数后，JavaScript 引擎会再次检查事件队列中是否有事件需要执行，如果有则重复步骤 4，否则继续等待新的事件加入事件队列。

6. 如果一个任务执行时间过长，会阻塞事件循环，导致其他任务无法执行。为了避免这种情况，可以将长时间的任务拆分成多个小任务，使用 setTimeout 或 setInterval 分批执行。

7. 另外，Promise 也是基于事件循环的机制实现的。当 Promise 状态发生改变时，会将对应的回调函数放入微任务队列中，等待当前任务执行完毕后立即执行。因此，Promise 的回调函数总是在当前任务执行完毕后立即执行，而不会被放入事件队列中等待执行。

## javascript 的任务分类

### 同步任务

同步任务介绍：就是只要被扫描到，就可以被主线程马上执行的任务。（优先于所有异步任务）

### 异步任务

异步任务介绍:即使被扫描到，也不会马上执行，异步任务会被压入异步任务队列中，等待主线程中的任务全部清空了，再被召唤执行。

常见的异步任务有如下几种

-   Promise.then() ---微任务
-   async/await ---Promise 的语法糖 ---微任务
-   setTimeout() ---宏任务
-   setInterval() ---宏任务
-   ...（还有更多，不常见的）

例如：

```javascript
setTimeout(() => {
    console.log('1')
}, 0)
console.log(2)

// 输出结果是 2，1。虽然setTimeout的延迟是0，但setTimeout是一个异步任务。
// 一定会在所有同步任务执行完毕之后再去执行。
```

### 宏任务与微任务

javascript 的异步任务又被分为宏任务和微任务。

在异步任务中，有些异步任务的平均执行周期很长，这些任务被 javascript 标记为宏任务(比如 setTimeout())。而平均执行周期相对比较短的任务，被 javascript 标记为微任务（比如 promise.then()）。

1. 当有异步任务被压入异步任务队列时候，javascript 会将这些异步任务分为宏任务和微任务两个新的队列。
2. 然后，在所有同步任务执行完毕之后，异步任务会优先执行所有已经存在任务队列中的微任务。
3. 在所有的微任务执行完毕之后，再去宏任务队列中执行一个（注意是一个）宏任务，执行完一个宏任务之后会再去微任务队列中检查是否有新的微任务，有则全部执行，再回到宏任务队列执行一个宏任务，以此循环。这一套流程，就是事件循环（event loop）

例如 1：

```javascript
setTimeout(() => {
    console.log('1')
}, 0) //异步任务 - 宏任务

console.log(2) //同步任务

Promise.resolve().then(() => {
    console.log(3)
}) //异步任务 - 微任务

console.log(6) //同步任务

// 输出结果：2 6 3 1
```

例如 2：

```javascript
//第一个宏任务
setTimeout(() => {
    console.log(1) //宏任务中的同步任务
    Promise.resolve().then(() => {
        console.log(7)
    }) //宏任务中的微任务
}, 0) //异步任务 - 宏任务

console.log(2) //同步任务

Promise.resolve().then(() => {
    console.log(3)
}) //异步任务 - 微任务

//第二个宏任务
setTimeout(() => {
    console.log(8) //宏任务中的同步任务
    setTimeout(() => {
        console.log(5)
    }, 0) //宏任务中的宏任务 第四个宏任务
}, 0)

//第三个宏任务
setTimeout(() => {
    Promise.resolve().then(() => {
        console.log(4)
    }) //宏任务中的微任务
}, 0)

console.log(6) //同步任务

// 输出结果：2 6 3 1 7 8 4 5
```

注意两点。

-   同一批次宏任务中按顺序执行
-   一次只执行一个宏任务，然后同步任务当场执行。微任务压入队列。然后就要去检查有没有微任务，有则执行

## 总结

0. javascript 是一个单线程语言

1. 同步任务优先于异步任务

2. 事件循环每一次只执行一个宏任务

3. 同一批次下微任务优先于宏任务
